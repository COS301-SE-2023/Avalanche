<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LevenshteinDistanceCalculator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">domain_watch</a> &gt; <a href="index.source.html" class="el_package">avalanche.DistanceCalculators</a> &gt; <span class="el_source">LevenshteinDistanceCalculator.java</span></div><h1>LevenshteinDistanceCalculator.java</h1><pre class="source lang-java linenums">package avalanche.DistanceCalculators;

import java.util.Arrays;
import java.util.HashSet;

import avalanche.Settings.DomainWatchSettings;

<span class="fc" id="L8">public class LevenshteinDistanceCalculator {</span>

    /**
     * Calculates the Levenshtein distance between two strings.
     * &lt;br/&gt;
     * Substitutions, deletions and insertions all invoke a cost of 1.&lt;br/&gt;
     * Certain special substitutions invoke a cost of 0.1. These can be found in the
     * domainWatch.conf file.&lt;br/&gt;
     * Repetitive insertions invoke a cost of 0.1. e.g oo-&gt;ooo = 0.1&lt;br/&gt;
     * Insetions of dash (-) invoke a cost of 0.1.&lt;br/&gt;
     * 
     * @param x The first string to compare.
     * @param y The second string to compare.
     * @return The levenshtein distance between the two string taking into account
     *         the special rules described.
     */
    public double calculateModifiedLevenshteinDistance(String x, String y, double limit) {
<span class="fc" id="L25">        x = x.toLowerCase();</span>
<span class="fc" id="L26">        y = y.toLowerCase();</span>

<span class="fc" id="L28">        double[][] dp = new double[x.length() + 1][y.length() + 1];</span>

<span class="fc bfc" id="L30" title="All 2 branches covered.">        for (int i = 0; i &lt;= x.length(); i++) {</span>
<span class="fc bfc" id="L31" title="All 2 branches covered.">            for (int j = 0; j &lt;= y.length(); j++) {</span>

<span class="fc bfc" id="L33" title="All 2 branches covered.">                if (i == 0) {</span>
<span class="fc bfc" id="L34" title="All 2 branches covered.">                    if (j == 0) {</span>
<span class="fc" id="L35">                        dp[i][j] = 0;</span>
<span class="fc" id="L36">                    } else {</span>
<span class="fc" id="L37">                        dp[i][j] = dp[i][j - 1] + 1;</span>
                    }
<span class="fc bfc" id="L39" title="All 2 branches covered.">                } else if (j == 0) {</span>
<span class="fc" id="L40">                    dp[i][j] = dp[i - 1][j] + 1;</span>

<span class="fc" id="L42">                } else {</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">                    if (i == 1) {</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">                        if (j == 1) {</span>
<span class="fc" id="L45">                            dp[i][j] = min(dp[i - 1][j - 1]</span>
<span class="fc" id="L46">                                    + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)),</span>
<span class="fc" id="L47">                                    dp[i - 1][j] + 1,</span>
<span class="fc" id="L48">                                    dp[i][j - 1] + 1);</span>
<span class="fc" id="L49">                        } else {</span>
<span class="fc" id="L50">                            dp[i][j] = min(dp[i - 1][j - 1]</span>
<span class="fc" id="L51">                                    + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)),</span>
<span class="fc" id="L52">                                    dp[i - 1][j] + 1,</span>
<span class="fc" id="L53">                                    dp[i][j - 1] + insertionCost(y.charAt(j - 1), y.charAt(j - 2)));</span>
                        }
<span class="fc bfc" id="L55" title="All 2 branches covered.">                    } else if (j == 1) {</span>
<span class="fc" id="L56">                        dp[i][j] = min(dp[i - 1][j - 1]</span>
<span class="fc" id="L57">                                + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)),</span>
<span class="fc" id="L58">                                dp[i - 1][j] + insertionCost(x.charAt(i - 1), x.charAt(i - 2)),</span>
<span class="fc" id="L59">                                dp[i][j - 1] + 1);</span>
<span class="fc" id="L60">                    } else {</span>
<span class="fc" id="L61">                        dp[i][j] = min(dp[i - 1][j - 1]</span>
<span class="fc" id="L62">                                + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)),</span>
<span class="fc" id="L63">                                dp[i - 1][j] + insertionCost(x.charAt(i - 1), x.charAt(i - 2)),</span>
<span class="fc" id="L64">                                dp[i][j - 1] + insertionCost(y.charAt(j - 1), y.charAt(j - 2)));</span>

                    }
                }

            }
        }

<span class="fc" id="L72">        return dp[x.length()][y.length()];</span>
    }

    /**
     * Returns the cost of an insertion of a specific character given the
     * &lt;br/&gt;
     * Should return 0.1 if the previous character is the same as the current
     * one&lt;br/&gt;
     * Should return 0.1 if current charater is a dash &quot;-&quot; (this may be buggy,
     * please test extra)&lt;br/&gt;
     * Should return 1 in all other cases.
     * 
     * @param currentCharacter  The current character being evaluated
     * @param previousCharacter The previous character that was evaluated (needed to
     *                          check for repitition)
     * @return Return 0.1 if the previous character is the same as the current
     *         one&lt;br/&gt;
     *         Should return 0.1 if current charater is a dash &quot;-&quot;&lt;br/&gt;
     *         Should return 1 in all other cases.
     */
    private double insertionCost(char currentCharacter, char previousCharacter) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (currentCharacter == previousCharacter) {</span>
<span class="fc" id="L94">            return 0.1;</span>
        }
<span class="fc bfc" id="L96" title="All 4 branches covered.">        if (currentCharacter == '-' || previousCharacter == '-') {</span>
<span class="fc" id="L97">            return 0.1;</span>
        }
<span class="fc" id="L99">        return 1;</span>
    }

    /**
     * Calculates the cost of a substitution from one character to another.
     * &lt;br/&gt;
     * Returns 0 if the characters are the same.&lt;br/&gt;
     * Returns 0.1 if the characters are in the list of similar values
     * &lt;ul&gt;
     * &lt;li&gt;If &quot;useInternalSubstitutionCosts&quot; in domainWatch.conf is true then the
     * in-code costs are used
     * &lt;/li&gt;
     * &lt;li&gt;If &quot;useInternalSubstitutionCosts&quot; in domainWatch.conf is false then the
     * costs from domainWatch.conf are used
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param characterFromString1
     * @param characterFromString2
     * @return Returns 0 if the characters are the same.&lt;br/&gt;
     *         Returns 0.1 if the characters are in the list of similar values
     *         &lt;ul&gt;
     *         &lt;li&gt;If &quot;useInternalSubstitutionCosts&quot; in domainWatch.conf is true
     *         then the
     *         in-code costs are used
     *         &lt;/li&gt;
     *         &lt;li&gt;If &quot;useInternalSubstitutionCosts&quot; in domainWatch.conf is false
     *         then the
     *         costs from domainWatch.conf are used
     *         &lt;/li&gt;
     *         &lt;/ul&gt;
     */
    private double costOfSubstitution(char characterFromString1, char characterFromString2) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (characterFromString1 == characterFromString2) {</span>
<span class="fc" id="L133">            return 0;</span>
        }

<span class="fc" id="L136">        DomainWatchSettings dws = DomainWatchSettings.getInstace();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (!dws.useInternalSubstitutionCosts) {</span>
<span class="fc" id="L138">            HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span>
<span class="fc" id="L139">            set.add(characterFromString1 + &quot;&quot;);</span>
<span class="fc" id="L140">            set.add(characterFromString2 + &quot;&quot;);</span>
<span class="fc" id="L141">            return dws.substitutionCosts.getOrDefault(set, (double) 1);</span>
        }

<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, '0', characterFromString2, 'o')) {</span>
<span class="fc" id="L145">            return 0.1;</span>
        }
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, 'i', characterFromString2, '1')) {</span>
<span class="fc" id="L148">            return 0.1;</span>
        }
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, 'l', characterFromString2, '1')) {</span>
<span class="fc" id="L151">            return 0.1;</span>
        }
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, 'l', characterFromString2, 'i')) {</span>
<span class="fc" id="L154">            return 0.1;</span>
        }
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, 'b', characterFromString2, '8')) {</span>
<span class="fc" id="L157">            return 0.1;</span>
        }
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, 'e', characterFromString2, '3')) {</span>
<span class="fc" id="L160">            return 0.1;</span>
        }
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, 'u', characterFromString2, 'v')) {</span>
<span class="fc" id="L163">            return 0.1;</span>
        }
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, '2', characterFromString2, 'z')) {</span>
<span class="fc" id="L166">            return 0.1;</span>
        }
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (checkBothWays(characterFromString1, 's', characterFromString2, '5')) {</span>
<span class="fc" id="L169">            return 0.1;</span>
        }

<span class="fc" id="L172">        return 1;</span>
    }

    /**
     * This function determines if two characters can be paired in either order, and
     * returns true if they can be paired in either way, and false otherwise.
     * 
     * @param characterFromString1
     * @param check1
     * @param characterFromString2
     * @param check2
     * @return True if (characterFromString1 is check1 and characterFromString2 is
     *         check2) or (characterFromString2 is check1 and characterFromString1
     *         is check2)
     */
    private boolean checkBothWays(char characterFromString1, char check1, char characterFromString2, char check2) {
<span class="fc bfc" id="L188" title="All 4 branches covered.">        return ((characterFromString1 == check1 &amp;&amp; characterFromString2 == check2)</span>
<span class="fc bfc" id="L189" title="All 4 branches covered.">                || (characterFromString1 == check2 &amp;&amp; characterFromString2 == check1));</span>
    }

    /**
     * Returns the smallest double of the parameters
     * 
     * @param numbers A variable number of doubles can be passed in
     * @return double: The smallest double from the parameters is returned
     */
    private double min(double... numbers) {
<span class="fc" id="L199">        return Arrays.stream(numbers)</span>
<span class="fc" id="L200">                .min().orElse(Integer.MAX_VALUE);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>